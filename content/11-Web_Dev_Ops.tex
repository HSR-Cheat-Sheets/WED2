%! Author = mariuszindel
%! Date = 24.01.21

\section{Web Dev-Ops}


\subsection{Sass (Syntactically Awesome Style Sheets)}
CSS Präprozessoren sind nicht an die Limitationen von CSS gebunden und ermöglichen es uns dadurch, (potentiell) besser wartbaren Code zu schreiben. $\rightarrow$  Weniger Copy \& Paste, Modularisierung, Wiederverwenden von Funktionalitäten.

\subsubsection{SASS vs. SCSS}
2 unterschiedliche Arten von Syntax:
\begin{itemize}
    \item SASS nur mit einrücken
    \item SCSS mit \texttt{;} und \texttt{\{\}}
\end{itemize}

\subsubsection{Spezielle Zeichen}
\textbf{\$} Variablen /
\textbf{\&} Referenz auf Parent Selector / \\
\textbf{\%} Placeholder /
\textbf{@} Steuerzeichen z.B. @if @else / 
\textbf{\#\{\}} Value einer Variable z.B. p.\#\{\$name\} { }

\subsubsection{Variablen}
\begin{lstlisting}
$purpele-navy: #635380; /* definition */
body {
color: $purpele-navy;}  /* Anwendung */
\end{lstlisting}

\subsubsection{Nesting}
\begin{lstlisting}
nav {                   /* SASS */
  ul {
    margin: 0;
      > li { display: inline-block; }}}}
nav ul { margin: 0; } /* wird zu CSS */
nav ul > li { display: inline-block; }
\end{lstlisting}

\subsubsection{Mixins}
Ermöglichen das Wiederverwenden von CSS
\begin{lstlisting}
@mixin visuallyhidden($abc: 1em) {   /* create */
    border: $abc;}
.element {                  /* use */
@include visuallyhidden(5em);}
\end{lstlisting}

\subsubsection{Extends / Inheritance}
\begin{itemize}
    \item gleicher Effekt wie mit Mixins
    \item Mixins generiert CSS mit mehr Redundanz
\end{itemize}
\begin{lstlisting}
.icon {                             /* SASS */
    transition: background-color ease .2s;
.error-icon { @extend .icon; /* error style ... */ }

.icon, .error-icon {                /* CSS */
    transition: background-color ease .2s; }
.error-icon { /* error style... */ }
\end{lstlisting}
Wird anstatt \texttt{.icon $\rightarrow$ \%icon} geschrieben, so ist es abstract und es wird kein \texttt{.icon} erzeugt.

\subsubsection{Programmierung}
\begin{lstlisting}
@each $point in $breakpoints {}   /* foreach */
@function properZero($para){      /* function */
    @if( ... ) { @return $para / 5; }}
@each $name, $hex in $colors {    /* Map */
    &-#{$name} {
color: $hex; } }

\end{lstlisting}

\subsubsection{Rechnen}
\begin{tabular}{p{1.3cm} l | p{1.3cm} l}
    2px + 2px & 4px       &   2 * 1px & 2px\\
    10 + px & «10px»      &   2px + 1mm & 5.7px\\
    1px * 2 & 2px         &   2px * 0 & 0px\\
    10px * 10px & «Error» &   10 + 0px & 10px\\
    (2 + px) * 2 &  «Error»&   2px / 1px & 2\\
\end{tabular}

\subsection{PostCSS}
PostCSS ist ein Tool zur Transformation von CSS mit JS-Plugins. Diese Plugins können Variablen und Mixins unterstützen, zukünftige CSS-Syntax, Inline-Bilder und mehr transpilieren.\\
Kurz: Man ist schneller, benötigt wehniger Code.

\subsection{Build Tools}
\textbf{Ziel:} Automatische Optimierung von
\begin{itemize}
    \item Performanz (z.B. first-contentful-paint, time-to-interative) wie sie z.B. Lighthouse
    \item X-Browser Unterstützung
\end{itemize}
\textbf{Features:}
\begin{itemize}
    \item Code Splitting («Tree Shaking»)
    \item X-Browser module-loading optimization
    \item Non-JS Resource loading-optimization
\end{itemize}

\vfill